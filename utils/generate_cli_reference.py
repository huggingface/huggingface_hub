import argparse
import html
import io
import re
import tempfile
from contextlib import redirect_stdout
from difflib import unified_diff
from pathlib import Path

from typer.cli import app as typer_main


PACKAGE_REFERENCE_PATH = Path(__file__).parents[1] / "docs" / "source" / "en" / "package_reference" / "cli.md"

# Hidden (deprecated) commands that should not appear in the generated reference.
HIDDEN_COMMANDS = ["repo-files"]

WARNING_HEADER = """<!--
# WARNING
# This entire file has been generated by Typer based on the `hf` CLI implementation.
# To re-generate the code, run `make style` or `python ./utils/generate_cli_reference.py --update`.
# WARNING
-->"""


def print_colored_diff(expected: str, current: str) -> None:
    """Print a colored line-by-line diff between expected and current content.

    Auto-generated code by Cursor.
    """
    expected_lines = expected.splitlines(keepends=True)
    current_lines = current.splitlines(keepends=True)

    diff = unified_diff(
        current_lines, expected_lines, fromfile="Current content", tofile="Expected content", lineterm=""
    )

    for line in diff:
        line = line.rstrip("\n")
        if line.startswith("+++"):
            print(f"\033[92m{line}\033[0m")  # Green for additions
        elif line.startswith("---"):
            print(f"\033[91m{line}\033[0m")  # Red for deletions
        elif line.startswith("@@"):
            print(f"\033[96m{line}\033[0m")  # Cyan for context
        elif line.startswith("+"):
            print(f"\033[92m{line}\033[0m")  # Green for additions
        elif line.startswith("-"):
            print(f"\033[91m{line}\033[0m")  # Red for deletions
        else:
            print(line)  # Default color for context


def _normalize_command_aliases(content: str) -> str:
    """Transform pipe-separated aliases into proper documentation format.

    Typer generates docs with pipe-separated command names (e.g. "list | ls") when
    commands have aliases. This function transforms them into a cleaner format:
    - Command list: `* `cmd | alias`: Desc` ‚Üí `* `cmd`: Desc [alias: alias]`
    - Section headers: `## `hf cmd | alias`` ‚Üí `## `hf cmd`` with alias in description
    - Usage examples: `$ hf cmd | alias [OPTIONS]` ‚Üí `$ hf cmd [OPTIONS]`
    """

    def _format_aliases(aliases: list[str]) -> str:
        return f"[alias: {', '.join(aliases)}]"

    # Transform command list items: `* `cmd | alias`: Description`
    # Only match simple command names (alphanumeric + hyphens), not options like `--format [table|json]`
    def _transform_list_item(match: re.Match) -> str:
        full_name = match.group(1)  # e.g. "list | ls"
        description = match.group(2)  # e.g. "List files..."
        parts = [p.strip() for p in full_name.split("|")]
        primary = parts[0]
        aliases = parts[1:]
        if aliases:
            return f"* `{primary}`: {description} {_format_aliases(aliases)}"
        return match.group(0)

    content = re.sub(
        r"^\* `([\w-]+(?: \| [\w-]+)+)`: (.*)$",
        _transform_list_item,
        content,
        flags=re.MULTILINE,
    )

    # Transform section headers: `## `hf cmd | alias`` or `### `hf parent cmd | alias``
    # and add alias info to the description on the next non-empty line
    def _transform_section(match: re.Match) -> str:
        hashes = match.group(1)  # "##" or "###"
        prefix = match.group(2)  # "hf" or "hf parent"
        full_name = match.group(3)  # "cmd | alias"
        whitespace = match.group(4)  # newlines between header and description
        description = match.group(5)  # first line of description

        parts = [p.strip() for p in full_name.split("|")]
        primary = parts[0]
        aliases = parts[1:]

        new_header = f"{hashes} `{prefix} {primary}`"
        if aliases:
            new_description = f"{description} {_format_aliases(aliases)}"
        else:
            new_description = description
        return f"{new_header}{whitespace}{new_description}"

    content = re.sub(
        r"^(#{2,}) `(hf(?: [\w-]+)*) ([\w-]+(?: \| [\w-]+)+)`(\n+)([^\n#*]+)",
        _transform_section,
        content,
        flags=re.MULTILINE,
    )

    # Transform usage examples in code blocks: `$ hf cmd | alias [OPTIONS]`
    def _transform_usage(match: re.Match) -> str:
        prefix = match.group(1)  # "$ hf" or "$ hf parent"
        full_name = match.group(2)  # "cmd | alias"
        suffix = match.group(3)  # " [OPTIONS]..." or similar

        parts = [p.strip() for p in full_name.split("|")]
        primary = parts[0]
        return f"{prefix} {primary}{suffix}"

    content = re.sub(
        r"^(\$ hf(?: [\w-]+)*) ([\w-]+(?: \| [\w-]+)+)( .*)$",
        _transform_usage,
        content,
        flags=re.MULTILINE,
    )

    return content


def _strip_hidden_commands(content: str, hidden_commands: list[str]) -> str:
    """Remove hidden/deprecated commands from the generated CLI reference.

    Typer's `utils docs` generates documentation for all commands including hidden
    ones. This function strips them from the output so they don't appear in the
    published reference.
    """
    for cmd in hidden_commands:
        # Remove bullet entry from top-level command list: `* `repo-files`: ...`
        content = re.sub(rf"^\* `{re.escape(cmd)}`:.*\n", "", content, flags=re.MULTILINE)

        # Remove the full section (## `hf <cmd>`) and any sub-sections (### `hf <cmd> ...`)
        # up to the next section at the same or higher level (##).
        content = re.sub(
            rf"^## `hf {re.escape(cmd)}`\n(?:(?!^## ).*\n)*",
            "",
            content,
            flags=re.MULTILINE,
        )

    return content


def generate_cli_reference() -> str:
    with tempfile.TemporaryDirectory() as tmpdir:
        tmp_file = Path(tmpdir) / "cli.md"
        try:
            with redirect_stdout(io.StringIO()):  # catch and ignore typer.echo output
                typer_main(
                    [
                        "src/huggingface_hub/cli/hf.py",
                        "utils",
                        "docs",
                        "--name",
                        "hf",
                        "--output",
                        str(tmp_file),
                    ]
                )
        except SystemExit as e:
            # Typer (Click) calls sys.exit() internally, so we catch it
            if e.code not in (0, None):
                raise  # re-raise if it was an error exit

        content = tmp_file.read_text()
        # Decode HTML entities that Typer generates
        content = html.unescape(content)
        content = _strip_hidden_commands(content, HIDDEN_COMMANDS)
        content = _normalize_command_aliases(content)
        return f"{WARNING_HEADER}\n\n{content}"


def check_and_update_cli_reference(update: bool, verbose: bool = False) -> None:
    new_content = generate_cli_reference()
    if PACKAGE_REFERENCE_PATH.exists():
        existing_content = PACKAGE_REFERENCE_PATH.read_text()
        if existing_content == new_content:
            print("‚úÖ All good! (CLI reference)")
            return
    elif not update:
        print(
            f"‚ùå `{PACKAGE_REFERENCE_PATH}` does not exist yet.\n"
            "   Please run `make style` or `python utils/generate_cli_reference.py --update` to generate it."
        )
        exit(1)

    if update:
        PACKAGE_REFERENCE_PATH.write_text(new_content)
        print(
            f"‚úÖ CLI reference has been updated in `{PACKAGE_REFERENCE_PATH}`.\n   Please make sure the changes are accurate and commit them."
        )
    else:
        print(
            f"‚ùå Expected content mismatch in `{PACKAGE_REFERENCE_PATH}`.\n"
            "   It is most likely that you've modified the CLI implementation and did not re-generate the docs.\n"
            "   Please run `make style` or `python utils/generate_cli_reference.py --update`."
        )

        if verbose:
            print("\nüìã Diff between current and expected content:")
            print_colored_diff(new_content, existing_content)

        exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--update",
        action="store_true",
        help=(f"Whether to re-generate `{PACKAGE_REFERENCE_PATH}` if a change is detected."),
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Show detailed diff when content mismatch is detected.",
    )
    args = parser.parse_args()
    check_and_update_cli_reference(update=args.update, verbose=args.verbose)
